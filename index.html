<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Japanese Dojo | Enhanced UI</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700&family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            /* --- Color Palette (Enhanced) --- */
            --bg-color: #f8f9fa;
            --surface-color: #ffffff;
            --primary-color: #1a73e8;
            --primary-variant: #0d62d9;
            --text-color: #202124;
            --text-secondary: #5f6368;
            --border-color: #dadce0;
            --shadow-color: rgba(60, 64, 67, 0.15);
            --success-color: #34a853;
            --error-color: #ea4335;
            
            /* Japanese-inspired colors */
            --japan-red: #bc002d;
            --japan-red-light: #fef4f4;
            --ink-black: #1c1c1c;

            /* --- UI Metrics --- */
            --border-radius-sm: 6px;
            --border-radius-md: 12px;
            --border-radius-lg: 16px;
            --transition-speed: 0.25s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(15px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @keyframes shimmer {
          100% { transform: translateX(100%); }
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Roboto', 'Noto Sans JP', sans-serif;
            line-height: 1.6;
            font-weight: 400;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            background-image: 
                radial-gradient(circle at 5% 10%, rgba(255, 209, 217, 0.15) 0%, transparent 20%),
                radial-gradient(circle at 95% 80%, rgba(255, 209, 217, 0.1) 0%, transparent 20%);
        }

        /* Decorative elements */
        .japanese-pattern {
            position: absolute;
            opacity: 0.03;
            pointer-events: none;
            z-index: -1;
            font-family: 'Noto Sans JP', sans-serif;
        }
        
        .pattern-1 {
            top: 10%; right: 5%; font-size: 8rem; transform: rotate(15deg);
        }
        
        .pattern-2 {
            bottom: 15%; left: 5%; font-size: 6rem; transform: rotate(-10deg);
        }

        /* --- Accessibility --- */
        :focus-visible {
            outline: 2px solid var(--primary-color);
            outline-offset: 2px;
            border-radius: var(--border-radius-sm);
        }

        .app-container {
            max-width: 1280px;
            margin: 0 auto;
            padding: 1.5rem 1rem;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            gap: 1.5rem;
            position: relative;
        }

        /* --- MODIFIED: Floating Action Button Styles --- */
        #random-word-btn {
            position: fixed;
            top: 50%; /* CHANGED from bottom */
            right: 1.5rem;
            transform: translateY(-50%); /* ADDED for vertical centering */
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--primary-variant) 100%);
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            display: grid;
            place-items: center;
            box-shadow: 0 6px 16px rgba(26, 115, 232, 0.35);
            transition: all var(--transition-speed) ease;
            z-index: 1000;
            overflow: hidden; /* Keep this to ensure spinner stays within bounds */
        }
        
        #random-word-btn:hover {
            transform: translateY(-50%) translateY(-3px) scale(1.05); /* MODIFIED to combine transforms */
            box-shadow: 0 8px 20px rgba(26, 115, 232, 0.4);
        }
        
        #random-word-btn:active {
            transform: translateY(-50%) scale(1); /* MODIFIED to combine transforms */
            box-shadow: 0 4px 10px rgba(26, 115, 232, 0.3);
        }

        #random-word-btn:disabled {
            cursor: not-allowed;
            background: #b0b0b0;
            box-shadow: none;
            transform: translateY(-50%); /* MODIFIED to maintain position */
        }
        
        /* --- ADDED: Rule to correctly size the SVG icon --- */
        #random-word-btn .btn-icon {
            width: 28px;
            height: 28px;
        }

        .spinner {
            width: 24px;
            height: 24px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
            display: none;
        }
        
        #random-word-btn.loading .spinner { display: block; }
        #random-word-btn.loading .btn-icon { display: none; }

        .content-grid {
            display: grid;
            grid-template-columns: 1fr 1.25fr;
            gap: 1.5rem;
            flex: 1;
        }

        @media (max-width: 900px) {
            .content-grid { grid-template-columns: 1fr; }
        }

        .content-section {
            display: flex;
            flex-direction: column;
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.4s ease, transform 0.4s ease;
            /* Performance optimization */
            will-change: opacity, transform;
            transform: translateZ(0) translateY(10px); /* GPU acceleration */
        }
        .content-section.active {
            opacity: 1;
            transform: translateZ(0) translateY(0); /* GPU acceleration */
        }

        .card {
            background-color: var(--surface-color);
            border-radius: var(--border-radius-lg);
            box-shadow: 0 4px 12px var(--shadow-color);
            border: 1px solid var(--border-color);
            overflow: hidden;
            flex: 1;
            display: flex;
            flex-direction: column;
            transition: box-shadow var(--transition-speed) ease, transform var(--transition-speed) ease;
            /* Performance optimization: Enable GPU acceleration */
            will-change: transform, box-shadow;
            transform: translateZ(0); /* Force hardware acceleration */
            backface-visibility: hidden; /* Prevent flickering */
        }
        
        .card:hover {
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12);
            transform: translateZ(0) translateY(-5px); /* Use translateZ(0) for GPU */
        }

        .word-info-card { padding: 1.5rem; }

        #display-word {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 1.25rem;
            padding-bottom: 1.25rem;
            border-bottom: 1px solid var(--border-color);
            position: relative;
            flex-direction: column;
            /* Enhanced for particle effects */
            overflow: hidden;
            min-height: 180px;
        }
        
        #display-word::after {
            content: "";
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 3px;
            background-color: var(--japan-red);
            border-radius: 3px;
        }

        .word-main {
            font-size: 3.5rem;
            font-weight: 700;
            color: var(--ink-black);
            line-height: 1.1;
            font-family: 'Noto Sans JP', sans-serif;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.05);
            /* Enhanced for character animations */
            position: relative;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.1em;
            /* Enable GPU acceleration for character animations */
            will-change: transform;
            transform: translateZ(0);
        }
        
        /* Word character animation styles */
        .word-char {
            display: inline-block;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            transform-origin: center center;
            /* GPU acceleration for each character */
            will-change: transform, color, text-shadow;
            transform: translateZ(0);
        }
        
        .word-char.audio-active {
            animation: charPulse 0.6s ease-in-out;
            color: var(--primary-color);
            text-shadow: 0 0 20px rgba(26, 115, 232, 0.5);
        }
        
        .word-char.frequency-high {
            transform: translateZ(0) scale(1.3) translateY(-8px) rotate(3deg);
            color: #ff6b6b;
            text-shadow: 0 0 25px rgba(255, 107, 107, 0.8), 0 0 35px rgba(255, 107, 107, 0.4);
        }
        
        .word-char.frequency-mid {
            transform: translateZ(0) scale(1.15) translateY(-4px) rotate(-2deg);
            color: #4ecdc4;
            text-shadow: 0 0 15px rgba(78, 205, 196, 0.7), 0 0 25px rgba(78, 205, 196, 0.3);
        }
        
        .word-char.frequency-low {
            transform: translateZ(0) scale(1.08) translateY(-2px) rotate(1deg);
            color: #45b7d1;
            text-shadow: 0 0 12px rgba(69, 183, 209, 0.6), 0 0 20px rgba(69, 183, 209, 0.2);
        }
        
        @keyframes charPulse {
            0% { transform: translateZ(0) scale(1); }
            30% { transform: translateZ(0) scale(1.2) rotate(3deg); }
            60% { transform: translateZ(0) scale(0.9) rotate(-2deg); }
            100% { transform: translateZ(0) scale(1); }
        }
        
        /* Spectrogram particles effect */
        .spectrogram-particles {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            overflow: hidden;
            z-index: 1;
        }
        
        .spectrum-particle {
            position: absolute;
            border-radius: 50%;
            animation: floatUp 2.5s ease-out forwards;
            pointer-events: none;
        }
        
        .spectrum-particle.high-freq {
            background: radial-gradient(circle, rgba(255, 107, 107, 0.8) 0%, rgba(255, 107, 107, 0.3) 50%, transparent 100%);
        }
        
        .spectrum-particle.mid-freq {
            background: radial-gradient(circle, rgba(78, 205, 196, 0.8) 0%, rgba(78, 205, 196, 0.3) 50%, transparent 100%);
        }
        
        .spectrum-particle.low-freq {
            background: radial-gradient(circle, rgba(69, 183, 209, 0.8) 0%, rgba(69, 183, 209, 0.3) 50%, transparent 100%);
        }
        
        @keyframes floatUp {
            0% {
                opacity: 0.9;
                transform: translateY(0) scale(0.3);
            }
            40% {
                opacity: 0.7;
                transform: translateY(-40px) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateY(-80px) scale(0.5);
            }
        }

        .word-reading {
            font-size: 1.25rem;
            font-family: 'Noto Sans JP', sans-serif;
            color: var(--text-secondary);
            font-weight: 400;
            padding: 0.25rem 1rem;
            background-color: var(--japan-red-light);
            border-radius: 8px;
        }

        .copy-btn {
            position: absolute;
            top: 0;
            right: 0;
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            display: grid;
            place-items: center;
            transition: all var(--transition-speed) ease;
        }
        
        .copy-btn:hover { 
            background-color: var(--japan-red-light); 
            color: var(--japan-red); 
        }
        
        .copy-btn svg { width: 18px; height: 18px; }

        .word-meanings {
            background: linear-gradient(to right, #f8f9fa, #f0f2f5);
            padding: 1.25rem;
            border-radius: var(--border-radius-md);
            margin: 1.25rem 0;
            text-align: center;
            border-left: 4px solid var(--primary-color);
            position: relative;
        }
        
        .word-meanings::before {
            content: '"';
            position: absolute;
            top: 0.5rem;
            left: 1rem;
            font-size: 3rem;
            color: rgba(0, 0, 0, 0.05);
            font-family: serif;
        }
        
        .simple-meanings {
            font-size: 1.1rem;
            font-weight: 500;
            color: var(--text-color);
        }

        .word-tags {
            margin-top: 1rem;
            display: flex; flex-wrap: wrap; gap: 0.5rem; justify-content: center;
        }
        
        .tag {
            background-color: #e8f0fe;
            color: var(--primary-color);
            padding: 0.375rem 0.875rem;
            border-radius: 50px;
            font-size: 0.8rem;
            font-weight: 500;
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
        }
        
        .tag::before {
            content: "â€¢";
            font-size: 1.5rem;
            line-height: 1;
        }
        
        .tag.jlpt, .tag.common {
            background-color: #e6f4ea;
            color: var(--success-color);
        }

        .section-title {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--ink-black);
            margin: 1.25rem 0 1rem 0;
            padding-bottom: 0.75rem;
            border-bottom: 2px solid var(--border-color);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .section-title::before {
            content: "";
            display: inline-block;
            width: 8px;
            height: 8px;
            background-color: var(--japan-red);
            border-radius: 50%;
        }
        
        #kanji-breakdown { display: flex; flex-direction: column; gap: 0.75rem; }
        
        /* Virtual scrolling styles */
        .virtual-scroll-container {
            overflow-y: auto;
            max-height: 400px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-md);
            background: var(--surface-color);
        }
        
        .virtual-items {
            will-change: transform;
        }
        
        .kanji-card {
            background: linear-gradient(to right, #f8f9fa, #f0f2f5);
            padding: 1rem;
            border-radius: var(--border-radius-md);
            display: flex;
            align-items: center;
            gap: 1rem;
            transition: all var(--transition-speed) ease;
            border-left: 3px solid transparent;
            /* Performance optimization */
            will-change: transform, border-left-color;
            transform: translateZ(0); /* Force GPU acceleration */
        }
        
        .kanji-card:hover {
            background: linear-gradient(to right, #f0f2f5, #e8ebf0);
            border-left-color: var(--japan-red);
            transform: translateZ(0) translateX(5px); /* GPU acceleration */
        }
        
        .kanji-char {
            font-size: 2rem;
            font-family: 'Noto Sans JP', sans-serif;
            color: var(--primary-color);
            background: linear-gradient(135deg, #e8f0fe 0%, #dde7f8 100%);
            width: 50px; height: 50px;
            display: grid; place-items: center;
            border-radius: var(--border-radius-md);
            flex-shrink: 0;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
            position: relative;
            overflow: hidden;
            /* Performance optimization */
            will-change: transform;
            transform: translateZ(0); /* GPU acceleration */
        }
        
        .kanji-char::after {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.4) 0%, transparent 100%);
        }
        
        /* Kanji character link styles - inherit all parent styles */
        .kanji-char-link {
            color: inherit;
            text-decoration: none;
            display: grid;
            place-items: center;
            width: 100%;
            height: 100%;
            position: relative;
            z-index: 1;
            transition: all var(--transition-speed) ease;
        }
        
        .kanji-char-link:hover {
            color: var(--japan-red);
            transform: translateZ(0) scale(1.05); /* GPU acceleration */
        }
        
        .kanji-char-link:focus {
            outline: 2px solid var(--primary-color);
            outline-offset: 2px;
            border-radius: var(--border-radius-sm);
        }
        
        .kanji-details { 
            flex-grow: 1; 
            position: relative;
        }
        
        .kanji-details-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 0.25rem;
        }
        
        .edit-rtk-btn {
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            display: grid;
            place-items: center;
            transition: all var(--transition-speed) ease;
            flex-shrink: 0;
            opacity: 0;
            transform: scale(0.8);
        }
        
        .kanji-card:hover .edit-rtk-btn {
            opacity: 1;
            transform: scale(1);
        }
        
        .edit-rtk-btn:hover {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }
        
        .edit-rtk-btn svg {
            width: 12px;
            height: 12px;
        }
        .kanji-meaning { font-size: 1.2rem; font-weight: 600; margin: 0 0 0.25rem 0; color: var(--ink-black); }
        .kanji-rtk { 
            font-size: 1.2rem; 
            color: var(--text-secondary); 
            margin: 0;
            line-height: 1.5;
        }
        
        /* Kanji link styles */
        .kanji-link {
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 500;
            border-radius: 3px;
            padding: 1px 3px;
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }
        
        .kanji-link:hover {
            background-color: var(--primary-color);
            color: white;
            text-decoration: none;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(26, 115, 232, 0.3);
        }
        
        .kanji-link:focus {
            outline: 2px solid var(--primary-color);
            outline-offset: 1px;
        }
        
        /* RTK Edit Modal Styles */
        .rtk-edit-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.6);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            backdrop-filter: blur(4px);
        }
        
        .rtk-edit-modal.active {
            display: flex;
            animation: fadeIn 0.3s ease;
        }
        
        .rtk-edit-content {
            background: var(--surface-color);
            border-radius: var(--border-radius-lg);
            padding: 2rem;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            transform: translateY(20px);
            animation: slideUp 0.3s ease forwards;
        }
        
        @keyframes slideUp {
            to {
                transform: translateY(0);
            }
        }
        
        .rtk-edit-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }
        
        .rtk-edit-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--text-color);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .rtk-edit-kanji {
            font-family: 'Noto Sans JP', sans-serif;
            color: var(--primary-color);
            background: linear-gradient(135deg, #e8f0fe 0%, #dde7f8 100%);
            padding: 0.25rem 0.5rem;
            border-radius: var(--border-radius-sm);
        }
        
        .rtk-edit-close {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            display: grid;
            place-items: center;
            transition: all var(--transition-speed) ease;
        }
        
        .rtk-edit-close:hover {
            background-color: var(--error-color);
            color: white;
        }
        
        .rtk-edit-form {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        .rtk-edit-label {
            font-weight: 500;
            color: var(--text-color);
            margin-bottom: 0.5rem;
        }
        
        .rtk-edit-textarea {
            width: 100%;
            min-height: 120px;
            padding: 1rem;
            border: 2px solid var(--border-color);
            border-radius: var(--border-radius-md);
            font-family: inherit;
            font-size: 1rem;
            line-height: 1.5;
            resize: vertical;
            transition: border-color var(--transition-speed) ease;
        }
        
        .rtk-edit-textarea:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(26, 115, 232, 0.1);
        }
        
        .rtk-edit-actions {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
            margin-top: 0.5rem;
        }
        
        .rtk-edit-btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: var(--border-radius-md);
            font-weight: 500;
            cursor: pointer;
            transition: all var(--transition-speed) ease;
            min-width: 100px;
        }
        
        .rtk-edit-btn.cancel {
            background: var(--bg-color);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
        }
        
        .rtk-edit-btn.cancel:hover {
            background: var(--border-color);
        }
        
        .rtk-edit-btn.save {
            background: var(--primary-color);
            color: white;
        }
        
        .rtk-edit-btn.save:hover {
            background: var(--primary-variant);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(26, 115, 232, 0.3);
        }
        
        .rtk-edit-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
        }
        
        .rtk-edit-loading {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .rtk-edit-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s linear infinite;
        }
        
        .error-message {
            background: #fce8e6;
            padding: 1rem;
            border-radius: var(--border-radius-md);
            color: var(--error-color);
            margin: 1rem 0;
            font-size: 0.9rem;
            border-left: 4px solid var(--error-color);
        }

        /* --- Immersion Kit Styles (Enhanced) --- */
        .immersion-content-wrapper {
            flex: 1; display: flex; flex-direction: column; position: relative; min-height: 350px;
        }
        
        .immersion-state-overlay {
            display: flex; justify-content: center; align-items: center; padding: 1.5rem;
            text-align: center; flex: 1; flex-direction: column; gap: 1rem;
        }
        
        .immersion-state-message { color: var(--text-secondary); font-size: 1rem; }
        .immersion-example-content { display: none; flex-direction: column; height: 100%; }
        
        .image-container {
            position: relative;
            width: 100%;
            height: 380px;
            overflow: hidden;
            background: linear-gradient(to right, #f8f9fa, #f0f2f5);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .example-image {
            width: 100%; height: 100%;
            object-fit: cover;
            transition: opacity 0.4s ease;
            cursor: pointer;
        }
        
        .example-image.loading { opacity: 0; }

        .audio-visualizer-container {
            position: absolute;
            bottom: 0; left: 0; right: 0;
            height: 50px;
            pointer-events: none;
            background: linear-gradient(to top, rgba(0,0,0,0.5), transparent);
            opacity: 0;
            transition: opacity var(--transition-speed) ease;
        }
        
        .audio-visualizer-container.is-playing { opacity: 1; }
        #audio-visualizer { width: 100%; height: 100%; }

        .example-text-container {
            padding: 1.25rem; flex: 1; display: flex; flex-direction: column;
            justify-content: center; min-height: 150px;
            background-color: #fcfcfc;
        }
        
        .example-sentence {
            font-family: 'Noto Sans JP', sans-serif; font-size: 2rem; text-align: center;
            line-height: 1.6; margin: 0 0 1rem 0;
            color: var(--ink-black); position: relative; padding: 0 1rem;
        }
        
        .example-sentence::before,
        .example-sentence::after {
            content: '"'; font-size: 1.75rem; color: rgba(0, 0, 0, 0.1); position: absolute;
        }
        
        .example-sentence::before { top: -0.5rem; left: 0; }
        .example-sentence::after { bottom: -1.5rem; right: 0; transform: rotate(180deg); }
        
        .example-translation {
            color: var(--text-secondary); font-size: 0.95rem; text-align: center;
            margin: 0; font-style: italic;
        }
        
        .ik-btn-overlay {
            position: absolute; bottom: 1rem; right: 1rem;
            background-color: rgba(255, 255, 255, 0.95); color: var(--primary-color);
            border: 1px solid var(--border-color); width: 44px; height: 44px;
            border-radius: 50%; cursor: pointer; display: grid; place-items: center;
            transition: all var(--transition-speed) ease; box-shadow: 0 4px 10px rgba(0,0,0,0.15);
            opacity: 0.85; backdrop-filter: blur(4px);
        }
        
        .ik-btn-overlay:hover { 
            background-color: white; transform: scale(1.1) translateY(-2px);
            opacity: 1; box-shadow: 0 6px 15px rgba(0,0,0,0.2);
            color: var(--japan-red);
        }
        
        .ik-btn-overlay svg { width: 22px; height: 22px; }
        
        .regular-nav {
            display: none; justify-content: space-between; align-items: center;
            padding: 0.75rem 1.25rem; border-top: 1px solid var(--border-color);
            background-color: var(--surface-color);
        }
        
        .example-counter { 
            color: var(--text-secondary); font-weight: 500; font-size: 0.85rem;
            display: flex; align-items: center; gap: 0.5rem;
        }
        
        .example-counter::before { content: "ðŸ”¢"; font-size: 0.85rem; }
        
        .nav-controls { display: flex; gap: 0.5rem; align-items: center; }
        
        .ik-btn {
            background-color: transparent; color: var(--text-secondary);
            border: 1px solid var(--border-color); border-radius: 10px;
            cursor: pointer; transition: all var(--transition-speed) ease;
            width: 40px; height: 40px; display: grid; place-items: center;
            position: relative; overflow: hidden;
            /* Performance optimization */
            will-change: transform, background-color;
            transform: translateZ(0); /* GPU acceleration */
        }
        
        .ik-btn svg { width: 20px; height: 20px; }
        
        .ik-btn:hover { 
            background-color: var(--bg-color); color: var(--primary-color);
            transform: translateZ(0) translateY(-2px); /* GPU acceleration */
            box-shadow: 0 3px 6px rgba(0,0,0,0.1);
        }
        
        .ik-btn.is-active { 
            background-color: var(--primary-color); color: white; border-color: var(--primary-color);
        }
        
        .skeleton-box {
            display: inline-block; height: 100%; width: 100%; position: relative;
            overflow: hidden; background: linear-gradient(to right, #f6f7f8 0%, #edeef1 20%, #f6f7f8 40%, #f6f7f8 100%);
            background-size: 200% 100%; animation: shimmer 1.5s infinite;
        }
        
        @media (max-width: 600px) {
            .app-container { padding: 0.75rem; gap: 1rem; }
            .word-main { font-size: 2.5rem; }
            .word-reading { font-size: 1.1rem; }
            .example-sentence { font-size: 1.1rem; }
            .image-container { height: 200px; }
            .example-text-container { padding: 1rem; min-height: 140px; }
            #random-word-btn {
                width: 54px;
                height: 54px;
                bottom: 1rem;
                right: 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="japanese-pattern pattern-1">æ—¥æœ¬èªž</div>
    <div class="japanese-pattern pattern-2">ç¿’</div>
    
    <div class="app-container">
        
        <div class="content-grid" id="content-grid">
            <section id="word-info-section" class="content-section">
                <div class="card word-info-card">
                    <div id="display-word">
                        <span class="word-main" role="status" aria-live="polite" tabindex="-1"></span>
                        <span class="word-reading"></span>
                        <button class="copy-btn" id="copy-word-btn" title="Copy Word" aria-label="Copy word to clipboard">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg>
                        </button>
                    </div>
                    <div class="word-details" id="word-details"></div>
                    
                    <h3 class="section-title">
                        <span>Kanji Breakdown</span>
                    </h3>
                    <div id="kanji-breakdown"></div>
                </div>
            </section>
            
            <section id="immersion-section" class="content-section">
                <div class="card" id="anki-immersion-container">
                    <!-- Immersion Kit UI will be generated here -->
                </div>
            </section>
        </div>
        
        <!-- MODIFIED: Floating Action Button (container div removed) -->
        <button id="random-word-btn" title="Discover New Word">
            <div class="spinner"></div>
            <svg class="btn-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                <path d="M22 15.5c0 1.33-2 2.5-2 2.5s-2-1.17-2-2.5c0-1.1.9-2 2-2s2 .9 2 2zM7.5 2c-1.11 0-2 .89-2 2v1.03c.23-.02.46-.03.7-.03.88 0 1.7.23 2.43.64.59-.26 1.25-.41 1.94-.41 1.18 0 2.25.51 3 1.28.75-.77 1.82-1.28 3-1.28 1.38 0 2.5 1.12 2.5 2.5 0 .61-.22 1.16-.59 1.59.32.22.59.53.59.91 0 .69-.56 1.25-1.25 1.25H10.9c-.06-2.09-1.76-3.75-3.87-3.75-.24 0-.47.02-.7.06V4c0-.55-.45-1-1-1s-1 .45-1 1v.06c-.23.04-.46.06-.7.06-2.11 0-3.81 1.66-3.87 3.75H.25C.11 8.81 0 8.69 0 8.55c0-.38.27-.69.59-.91C.22 7.16 0 6.61 0 6c0-1.38 1.12-2.5 2.5-2.5 1.18 0 2.25.51 3 1.28C6.25 2.51 7.32 2 8.5 2c.35 0 .69.06 1 .16.59-.74 1.54-1.16 2.5-1.16s1.91.42 2.5 1.16c.31-.1.65-.16 1-.16 1.18 0 2.25.51 3 1.28C19.25 2.51 20.32 2 21.5 2c.35 0 .69.06 1 .16.59-.74 1.54-1.16 2.5-1.16s1.91.42 2.5 1.16c.31-.1.65-.16 1-.16.34 0 .67.04 1 .12V4c0-1.11-.89-2-2-2h-1.5zm-1.5 6c0 1.33-2 2.5-2 2.5s-2-1.17-2-2.5c0-1.1.9-2 2-2s2 .9 2 2zM4 15.5c0 1.1.9 2 2 2s2-.9 2-2c0-1.33-2-2.5-2-2.5S4 14.17 4 15.5zM15 8c-1.1 0-2 .9-2 2c0 1.33-2 2.5-2 2.5S9 11.33 9 10c0-1.1-.9-2-2-2s-2 .9-2 2c0 1.33-2 2.5-2 2.5S1 11.33 1 10c0-1.1-.9-2-2-2s-2 .9-2 2c0 1.33-2 2.5-2 2.5V19c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2v-6.5S20 11.33 20 10c0-1.1-.9-2-2-2s-2 .9-2 2z"></path>
            </svg>
        </button>
        
        <!-- RTK Edit Modal -->
        <div class="rtk-edit-modal" id="rtk-edit-modal">
            <div class="rtk-edit-content">
                <div class="rtk-edit-header">
                    <h2 class="rtk-edit-title">
                        Edit RTK for <span class="rtk-edit-kanji" id="rtk-edit-kanji"></span>
                    </h2>
                    <button class="rtk-edit-close" onclick="closeRTKEditModal()" title="Close">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
                        </svg>
                    </button>
                </div>
                <form class="rtk-edit-form" onsubmit="saveRTKEdit(event)">
                    <div>
                        <label class="rtk-edit-label" for="rtk-edit-textarea">
                            RTK (Remembering the Kanji) Mnemonic:
                        </label>
                        <textarea 
                            id="rtk-edit-textarea" 
                            class="rtk-edit-textarea" 
                            placeholder="Enter your RTK mnemonic here..."
                            required
                        ></textarea>
                    </div>
                    <div class="rtk-edit-actions">
                        <button type="button" class="rtk-edit-btn cancel" onclick="closeRTKEditModal()">
                            Cancel
                        </button>
                        <button type="submit" class="rtk-edit-btn save" id="rtk-save-btn">
                            <span class="rtk-save-text">Save</span>
                            <span class="rtk-edit-loading" style="display: none;">
                                <span class="rtk-edit-spinner"></span>
                                Saving...
                            </span>
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <script>
    'use strict';
    // --- Performance Enhancements ---
    const CACHE_VERSION = '1.0';
    const CACHE_EXPIRY = 24 * 60 * 60 * 1000; // 24 hours
    
    // --- Data Stores ---
    let KANJI_DATA = [];
    let WORD_LIST = [];
    let kanjiMap = new Map();
    let wordDetailsCache = new Map();
    let imageCache = new Map();
    
    // --- Performance Monitoring ---
    const performance = {
        startTime: Date.now(),
        loadTimes: {},
        metrics: {
            totalWords: 0,
            totalKanji: 0,
            cacheHits: 0,
            cacheMisses: 0,
            apiCalls: 0
        },
        mark: function(name) {
            this.loadTimes[name] = Date.now() - this.startTime;
            console.log(`âš¡ ${name}: ${this.loadTimes[name]}ms`);
        },
        recordCacheHit: function() {
            this.metrics.cacheHits++;
        },
        recordCacheMiss: function() {
            this.metrics.cacheMisses++;
        },
        recordApiCall: function() {
            this.metrics.apiCalls++;
        },
        getReport: function() {
            const total = Date.now() - this.startTime;
            const cacheHitRate = this.metrics.cacheHits / (this.metrics.cacheHits + this.metrics.cacheMisses) * 100;
            return {
                totalTime: total,
                loadTimes: this.loadTimes,
                cacheHitRate: cacheHitRate.toFixed(1) + '%',
                metrics: this.metrics
            };
        },
        logReport: function() {
            const report = this.getReport();
            console.group('ðŸ“Š Performance Report');
            console.log('Total Runtime:', report.totalTime + 'ms');
            console.log('Cache Hit Rate:', report.cacheHitRate);
            console.log('API Calls Made:', report.metrics.apiCalls);
            console.log('Load Times:', report.loadTimes);
            console.groupEnd();
        }
    };
    
    // Log performance report every 30 seconds
    setInterval(() => performance.logReport(), 30000);

    // --- RTK Text Processing Function ---
    function processRTKText(rtkText) {
        if (!rtkText) return '';
        
        let processedText = rtkText;
        
        // Step 1: Process markup patterns first
        // Convert *text* to <strong>text</strong>
        processedText = processedText.replace(/\*([^*]+)\*/g, '<strong>$1</strong>');

        // Convert #text# to <em>text</em>
        processedText = processedText.replace(/#([^#]+)#/g, '<em>$1</em>');
        
        // Step 2: Convert {kanji} to links
        processedText = processedText.replace(/\{([\u4e00-\u9faf]+)\}/g, '<a href="https://kanji.koohii.com/study/kanji/$1" target="_blank" class="kanji-link">$1</a>');
        
        // Step 3: Convert remaining standalone kanji to links
        // Split by HTML tags to avoid processing inside tags
        const parts = processedText.split(/(<[^>]*>)/);
        
        for (let i = 0; i < parts.length; i++) {
            // Only process text parts (not HTML tags)
            if (!parts[i].startsWith('<')) {
                parts[i] = parts[i].replace(/([\u4e00-\u9faf])/g, '<a href="https://kanji.koohii.com/study/kanji/$1" target="_blank" class="kanji-link">$1</a>');
            }
        }
        
        return parts.join('');
    }

    // --- DOM Elements ---
    const randomWordBtn = document.getElementById('random-word-btn');
    const kanjiBreakdownEl = document.getElementById('kanji-breakdown');
    const copyWordBtn = document.getElementById('copy-word-btn');
    const wordInfoSection = document.getElementById('word-info-section');
    const immersionSection = document.getElementById('immersion-section');

    // --- SVG Icon Library ---
    const ICONS = {
        PLAY: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>`,
        STOP: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M6 6h12v12H6z"/></svg>`,
        PREV: `<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="currentColor"><path d="M0 0h24v24H0z" fill="none"/><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/></svg>`,
        NEXT: `<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="currentColor"><path d="M0 0h24v24H0z" fill="none"/><path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/></svg>`,
        LOOP: `<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="currentColor"><path d="M0 0h24v24H0z" fill="none"/><path d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4z"/></svg>`,
        RETRY: `<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="currentColor"><path d="M0 0h24v24H0z" fill="none"/><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></svg>`
    };

    // --- Virtual Scrolling System ---
    class VirtualScrollRenderer {
        constructor(container, itemHeight = 80) {
            this.container = container;
            this.itemHeight = itemHeight;
            this.visibleItems = 10; // Number of items to render
            this.buffer = 5; // Extra items to render for smooth scrolling
            this.items = [];
            this.scrollTop = 0;
            this.renderedItems = new Map();
            this.isVirtualMode = false;
        }
        
        shouldUseVirtualScrolling(itemCount) {
            return itemCount > 50; // Use virtual scrolling for large lists
        }
        
        setItems(items) {
            this.items = items;
            this.isVirtualMode = this.shouldUseVirtualScrolling(items.length);
            
            if (this.isVirtualMode) {
                this.setupVirtualScrolling();
                performance.mark(`Virtual scrolling enabled for ${items.length} items`);
            } else {
                this.renderAllItems();
            }
        }
        
        setupVirtualScrolling() {
            const totalHeight = this.items.length * this.itemHeight;
            
            // Create virtual container
            this.container.innerHTML = `
                <div class="virtual-scroll-container" style="height: ${totalHeight}px; position: relative;">
                    <div class="virtual-items" style="position: absolute; top: 0; width: 100%;"></div>
                </div>
            `;
            
            this.virtualContainer = this.container.querySelector('.virtual-scroll-container');
            this.itemsContainer = this.container.querySelector('.virtual-items');
            
            // Add scroll listener
            this.virtualContainer.addEventListener('scroll', 
                PerformanceUtils.throttle(() => this.handleScroll(), 16) // 60fps
            );
            
            this.renderVisibleItems();
        }
        
        handleScroll() {
            this.scrollTop = this.virtualContainer.scrollTop;
            this.renderVisibleItems();
        }
        
        renderVisibleItems() {
            const startIndex = Math.max(0, Math.floor(this.scrollTop / this.itemHeight) - this.buffer);
            const endIndex = Math.min(this.items.length, startIndex + this.visibleItems + this.buffer * 2);
            
            // Clear container
            this.itemsContainer.innerHTML = '';
            
            // Render visible items
            for (let i = startIndex; i < endIndex; i++) {
                const item = this.items[i];
                const element = this.createKanjiElement(item, i * this.itemHeight);
                this.itemsContainer.appendChild(element);
            }
            
            performance.mark(`Rendered ${endIndex - startIndex} virtual items`);
        }
        
        createKanjiElement(kanjiData, offsetTop) {
            const div = document.createElement('div');
            div.className = 'kanji-card';
            div.style.position = 'absolute';
            div.style.top = offsetTop + 'px';
            div.style.width = '100%';
            div.style.height = this.itemHeight + 'px';
            
            const processedRTK = processRTKText(kanjiData.rtk);
            div.innerHTML = `
                <div class="kanji-char">
                    <a href="https://kanji.koohii.com/study/kanji/${kanjiData.kanji}" target="_blank" class="kanji-char-link">
                        ${kanjiData.kanji}
                    </a>
                </div>
                <div class="kanji-details">
                    <div class="kanji-details-header">
                        <h3 class="kanji-meaning">${kanjiData.meaning}</h3>
                        <button class="edit-rtk-btn" onclick="openRTKEditModal('${kanjiData.kanji}', '${kanjiData.meaning}', '${kanjiData.rtk ? kanjiData.rtk.replace(/'/g, '&apos;').replace(/"/g, '&quot;') : ''}')" title="Edit RTK">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
                            </svg>
                        </button>
                    </div>
                    <p class="kanji-rtk">${processedRTK}</p>
                </div>
            `;
            
            return div;
        }
        
        renderAllItems() {
            // Standard rendering for smaller lists
            let html = '';
            this.items.forEach(kanjiData => {
                const processedRTK = processRTKText(kanjiData.rtk);
                html += `
                    <div class="kanji-card">
                        <div class="kanji-char">
                            <a href="https://kanji.koohii.com/study/kanji/${kanjiData.kanji}" target="_blank" class="kanji-char-link">
                                ${kanjiData.kanji}
                            </a>
                        </div>
                        <div class="kanji-details">
                            <div class="kanji-details-header">
                                <h3 class="kanji-meaning">${kanjiData.meaning}</h3>
                                <button class="edit-rtk-btn" onclick="openRTKEditModal('${kanjiData.kanji}', '${kanjiData.meaning}', '${kanjiData.rtk ? kanjiData.rtk.replace(/'/g, '&apos;').replace(/"/g, '&quot;') : ''}')" title="Edit RTK">
                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                                        <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
                                    </svg>
                                </button>
                            </div>
                            <p class="kanji-rtk">${processedRTK}</p>
                        </div>
                    </div>
                `;
            });
            
            this.container.innerHTML = html;
        }
    }

    // --- Image Optimization System ---
    class ImageOptimizer {
        constructor() {
            this.preloadQueue = [];
            this.preloadedImages = new Map();
            this.compressionCanvas = document.createElement('canvas');
            this.compressionCtx = this.compressionCanvas.getContext('2d');
            this.maxCacheSize = 20; // Max preloaded images
            this.supportsWebP = this.checkWebPSupport();
        }
        
        checkWebPSupport() {
            const canvas = document.createElement('canvas');
            canvas.width = 1;
            canvas.height = 1;
            return canvas.toDataURL('image/webp').indexOf('webp') > 0;
        }
        
        async preloadImage(url) {
            if (this.preloadedImages.has(url)) {
                return this.preloadedImages.get(url);
            }
            
            try {
                const response = await serverFetch(url);
                const blob = await response.blob();
                
                // Compress if image is too large
                const compressedBlob = await this.compressImage(blob);
                
                // Cache the compressed image
                if (this.preloadedImages.size >= this.maxCacheSize) {
                    // Remove oldest entry
                    const firstKey = this.preloadedImages.keys().next().value;
                    this.preloadedImages.delete(firstKey);
                }
                
                this.preloadedImages.set(url, compressedBlob);
                performance.mark(`Image preloaded: ${url.split('/').pop()}`);
                
                return compressedBlob;
            } catch (error) {
                console.warn('Image preload failed:', error);
                return null;
            }
        }
        
        async compressImage(blob, maxWidth = 800, quality = 0.8) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    // Skip compression if image is already small
                    if (img.width <= maxWidth) {
                        resolve(blob);
                        return;
                    }
                    
                    // Calculate new dimensions
                    const ratio = Math.min(maxWidth / img.width, maxWidth / img.height);
                    const newWidth = Math.floor(img.width * ratio);
                    const newHeight = Math.floor(img.height * ratio);
                    
                    // Resize using canvas
                    this.compressionCanvas.width = newWidth;
                    this.compressionCanvas.height = newHeight;
                    
                    this.compressionCtx.imageSmoothingEnabled = true;
                    this.compressionCtx.imageSmoothingQuality = 'high';
                    this.compressionCtx.drawImage(img, 0, 0, newWidth, newHeight);
                    
                    // Use WebP if supported, otherwise JPEG
                    const format = this.supportsWebP ? 'image/webp' : 'image/jpeg';
                    const webpQuality = this.supportsWebP ? quality * 0.9 : quality; // WebP is more efficient
                    
                    this.compressionCanvas.toBlob((compressedBlob) => {
                        if (compressedBlob && compressedBlob.size < blob.size) {
                            performance.mark(`Image compressed: ${((1 - compressedBlob.size / blob.size) * 100).toFixed(1)}% reduction`);
                            resolve(compressedBlob);
                        } else {
                            // Use original if compression didn't help
                            resolve(blob);
                        }
                    }, format, webpQuality);
                };
                img.src = URL.createObjectURL(blob);
            });
        }
        
        preloadImagesInBackground(urls) {
            // Preload images during idle time
            urls.forEach((url, index) => {
                setTimeout(() => {
                    PerformanceUtils.requestIdleCallback(() => {
                        this.preloadImage(url);
                    });
                }, index * 100); // Stagger requests
            });
        }
    }
    
    const imageOptimizer = new ImageOptimizer();

    // --- Lazy Loading System ---
    class LazyLoader {
        constructor() {
            this.pageSize = 1000; // Load 1000 items at a time
            this.loadedPages = new Set();
            this.isLoading = false;
        }
        
        async loadDataChunk(type, page = 0) {
            if (this.loadedPages.has(`${type}_${page}`) || this.isLoading) {
                return null;
            }
            
            this.isLoading = true;
            const offset = page * this.pageSize;
            
            try {
                const endpoint = type === 'words' ? '/api/words' : '/api/kanji';
                const url = `${endpoint}?limit=${this.pageSize}&offset=${offset}`;
                const response = await fetch(url);
                
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const data = await response.json();
                
                this.loadedPages.add(`${type}_${page}`);
                performance.mark(`Lazy loaded ${type} page ${page}`);
                
                return data;
            } catch (error) {
                console.error(`Failed to lazy load ${type} page ${page}:`, error);
                return null;
            } finally {
                this.isLoading = false;
            }
        }
        
        async preloadNextChunk(type, currentPage) {
            // Preload next page in background
            setTimeout(() => {
                this.loadDataChunk(type, currentPage + 1);
            }, 100);
        }
    }
    
    const lazyLoader = new LazyLoader();

    // --- Performance Utilities ---
    class PerformanceUtils {
        static debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
        
        static throttle(func, limit) {
            let inThrottle;
            return function(...args) {
                if (!inThrottle) {
                    func.apply(this, args);
                    inThrottle = true;
                    setTimeout(() => inThrottle = false, limit);
                }
            };
        }
        
        static requestIdleCallback(callback) {
            if (window.requestIdleCallback) {
                return window.requestIdleCallback(callback);
            } else {
                return setTimeout(callback, 1);
            }
        }
    }

    // --- Caching Utilities ---
    class CacheManager {
        static setCache(key, data, expiry = CACHE_EXPIRY) {
            const item = {
                data,
                timestamp: Date.now(),
                expiry
            };
            try {
                localStorage.setItem(`jdojo_${CACHE_VERSION}_${key}`, JSON.stringify(item));
            } catch (e) {
                console.warn('Cache storage failed:', e);
            }
        }
        
        static getCache(key) {
            try {
                const item = localStorage.getItem(`jdojo_${CACHE_VERSION}_${key}`);
                if (!item) return null;
                
                const parsed = JSON.parse(item);
                if (Date.now() - parsed.timestamp > parsed.expiry) {
                    localStorage.removeItem(`jdojo_${CACHE_VERSION}_${key}`);
                    return null;
                }
                return parsed.data;
            } catch (e) {
                return null;
            }
        }
        
        static clearOldCache() {
            const keys = Object.keys(localStorage);
            keys.forEach(key => {
                if (key.startsWith('jdojo_') && !key.startsWith(`jdojo_${CACHE_VERSION}_`)) {
                    localStorage.removeItem(key);
                }
            });
        }
    }

    // --- API & Data Handling ---
    async function serverFetch(targetUrl, params = {}) {
        const endpoint = targetUrl.includes('jisho.org') ? '/api/jisho' : '/api/immersion-kit';
        const allParams = new URLSearchParams(params);
        if (endpoint === '/api/immersion-kit') {
            allParams.set('targetUrl', targetUrl);
        }
        const fetchUrl = `${endpoint}?${allParams.toString()}`;
        return fetch(fetchUrl);
    }

    async function fetchWordDetails(word) {
        // Check cache first
        const cacheKey = `word_${word}`;
        const cached = wordDetailsCache.get(word) || CacheManager.getCache(cacheKey);
        if (cached) {
            wordDetailsCache.set(word, cached);
            performance.recordCacheHit();
            return cached;
        }
        
        performance.recordCacheMiss();
        performance.recordApiCall();
        
        try {
            performance.mark(`Word fetch start: ${word}`);
            const response = await serverFetch('https://jisho.org/api/v1/search/words', { keyword: word });
            if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            const data = await response.json();
            if (!data.data || data.data.length === 0) return null;
            
            const entry = data.data.find(d => d.japanese[0].word === word) || data.data[0];
            const result = {
                word: entry.japanese[0]?.word || word,
                reading: entry.japanese[0]?.reading || '',
                isCommon: entry.is_common,
                jlpt: entry.jlpt || [],
                firstSense: entry.senses?.[0] || null,
                tags: entry.tags || []
            };
            
            // Cache the result
            wordDetailsCache.set(word, result);
            CacheManager.setCache(cacheKey, result);
            performance.mark(`Word fetch end: ${word}`);
            
            return result;
        } catch (error) {
            console.error('âŒ Jisho API Error:', error);
            throw error;
        }
    }

    // ðŸš€ OPTIMIZATION: Background loading functions (non-blocking)
    async function fetchWordDetailsBackground(word) {
        try {
            return await fetchWordDetails(word);
        } catch (error) {
            console.warn('Background word details loading failed:', error);
            return null;
        }
    }

    async function loadKanjiDataBackground(word) {
        return new Promise((resolve) => {
            PerformanceUtils.requestIdleCallback(() => {
                const uniqueKanji = [...new Set(word.match(/[\u4e00-\u9faf]/g) || [])];
                if (uniqueKanji.length > 0) {
                    const kanjiDataList = uniqueKanji.map(kanji => kanjiMap.get(kanji)).filter(Boolean);
                    
                    if (kanjiDataList.length > 0) {
                        // Use virtual scrolling for large lists
                        const virtualRenderer = new VirtualScrollRenderer(kanjiBreakdownEl);
                        virtualRenderer.setItems(kanjiDataList);
                    } else {
                        kanjiBreakdownEl.innerHTML = `<p style="text-align:center; color: var(--text-secondary);">Kanji data not available.</p>`;
                    }
                } else {
                    kanjiBreakdownEl.innerHTML = `<p style="text-align:center; color: var(--text-secondary);">This word contains no kanji.</p>`;
                }
                resolve(true);
            });
        });
    }

    // --- UI Update Functions ---
    function displayWordDetails(wordData) {
        const wordDetailsEl = document.getElementById('word-details');
        const wordMainEl = document.querySelector('.word-main');
        const wordReadingEl = document.querySelector('.word-reading');
        
        if (!wordData) {
            wordDetailsEl.innerHTML = '<p style="color: var(--text-secondary); text-align: center;">Word details not available</p>';
            wordMainEl.textContent = 'Unknown'; 
            wordReadingEl.textContent = ''; 
            return;
        }

        wordMainEl.textContent = wordData.word;
        wordMainEl.focus(); // Set focus for screen readers
        wordReadingEl.textContent = (wordData.reading && wordData.reading !== wordData.word) ? `(${wordData.reading})` : '';
        
        let html = '';
        if (wordData.firstSense?.english_definitions) {
            html += `<div class="word-meanings"><p class="simple-meanings">${wordData.firstSense.english_definitions.join('; ')}</p></div>`;
        }
        
        const tags = [];
        if (wordData.isCommon) tags.push('<span class="tag common">Common</span>');
        wordData.jlpt.forEach(level => tags.push(`<span class="tag jlpt">${level.toUpperCase()}</span>`));
        wordData.tags.forEach(tag => tags.push(`<span class="tag">${tag}</span>`));
        // if (tags.length > 0) {
        //     html += `<div class="word-tags">${tags.join('')}</div>`;
        // }

        wordDetailsEl.innerHTML = html;
    }

    // --- Word Animation Utilities ---
    function prepareWordForAnimation(word) {
        const wordElement = document.querySelector('.word-main');
        if (!wordElement) return;
        
        // Clear any existing particles
        const existingParticles = document.querySelector('.spectrogram-particles');
        if (existingParticles) {
            existingParticles.remove();
        }
        
        // Split word into individual character spans for animation
        wordElement.innerHTML = word
            .split('')
            .map(char => `<span class="word-char">${char}</span>`)
            .join('');
        
        // Add particle container to display-word
        const displayWordContainer = document.getElementById('display-word');
        if (displayWordContainer && !displayWordContainer.querySelector('.spectrogram-particles')) {
            const particleContainer = document.createElement('div');
            particleContainer.className = 'spectrogram-particles';
            displayWordContainer.appendChild(particleContainer);
        }
        
        console.log(`ðŸŽ¨ Prepared "${word}" for spectrogram animation with ${word.length} characters`);
    }
    
    // --- Main Application Logic ---
    const showRandomWordThrottled = PerformanceUtils.throttle(async function() {
        if (WORD_LIST.length === 0) return;

        // Animate out the old content for a smooth transition
        wordInfoSection.classList.remove('active');
        immersionSection.classList.remove('active');

        randomWordBtn.classList.add('loading');
        randomWordBtn.disabled = true;
        
        const word = WORD_LIST[Math.floor(Math.random() * WORD_LIST.length)];
        
        // ðŸš€ OPTIMIZATION: Show word immediately for instant feedback
        document.querySelector('.word-main').textContent = word;
        prepareWordForAnimation(word);
        
        // Show the word section immediately with basic content
        document.querySelector('.word-reading').textContent = '';
        document.getElementById('word-details').innerHTML = '<p style="color: var(--text-secondary); text-align: center;">Loading word details...</p>';
        kanjiBreakdownEl.innerHTML = '<p style="color: var(--text-secondary); text-align: center;">Loading kanji breakdown...</p>';
        
        // Show the UI immediately
        setTimeout(() => {
            wordInfoSection.classList.add('active');
            immersionSection.classList.add('active');
        }, 50);
        
        // Re-enable button immediately for better UX
        randomWordBtn.classList.remove('loading');
        randomWordBtn.disabled = false;
        
        // ðŸš€ OPTIMIZATION: Load API data in background (non-blocking)
        Promise.allSettled([
            fetchWordDetailsBackground(word),
            immersionHandler.fetchExamplesBackground(word),
            loadKanjiDataBackground(word)
        ]).then(([wordResult, examplesResult, kanjiResult]) => {
            // Update UI with loaded data as it becomes available
            if (wordResult.status === 'fulfilled' && wordResult.value) {
                displayWordDetails(wordResult.value);
            } else {
                displayWordDetails(null);
            }
        }).catch(error => {
            console.warn('Background loading error:', error);
        });
    }, 1000); // Throttle to max 1 request per second
    
    async function showRandomWord() {
        return showRandomWordThrottled();
    }

    // --- Immersion Kit Handler Class ---
    class ImmersionKitHandler {
        constructor() {
            this.examples = []; this.currentIndex = 0; this.isPlayingAll = false;
            // Restore loop state from localStorage using versioned key to prevent clearing
            this.isLoopingAudio = localStorage.getItem(`jdojo_${CACHE_VERSION}_loop_state`) === 'true';
            this.lastSearchWord = null; this.container = null; this.elements = {};
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            this.currentAudioSource = null; this.analyserNode = null; this.visualizerAnimationId = null;
            this.lastPlayId = 0; this.currentImageBlobUrl = null;
            this.deckTitleMap = null;
            this.initUI();
            this.initAudio();
        }
        
        initUI() {
            this.container = document.getElementById('anki-immersion-container');
            this.container.innerHTML = this._getInitialHTML();
            this._cacheElements();
            this._addEventListeners();
        }

        initAudio() {
            this.analyserNode = this.audioContext.createAnalyser();
            this.analyserNode.fftSize = 256;
        }

        _getInitialHTML() {
            return `
            <div class="immersion-content-wrapper">
                <div class="immersion-state-overlay">
                    <p class="immersion-state-message">Loading examples...</p>
                    <div class="error-details" style="display: none;"></div>
                </div>
                <div class="immersion-example-content">
                    <div class="image-container">
                        <div class="skeleton-box"></div>
                        <img data-action="play-audio" class="example-image" alt="Example Scene" style="display: none;">
                        <div class="audio-visualizer-container"><canvas id="audio-visualizer"></canvas></div>
                        <button data-action="play-audio" class="ik-btn-overlay" title="Play Audio" style="display: none;">${ICONS.PLAY}</button>
                    </div>
                    <div class="example-text-container">
                        <p class="example-sentence"></p>
                        <p class="example-translation"></p>
                    </div>
                </div>
            </div>
            <div class="regular-nav">
                <span class="example-counter"></span>
                <div class="nav-controls">
                    <button data-action="prev-example" class="ik-btn" title="Previous">${ICONS.PREV}</button>
                    <button data-action="next-example" class="ik-btn" title="Next">${ICONS.NEXT}</button>
                    <button data-action="toggle-loop" class="ik-btn" title="Loop audio">${ICONS.LOOP}</button>
                    <button data-action="play-all" class="ik-btn" title="Play all">${ICONS.PLAY}</button>
                    <button data-action="retry" class="ik-btn" title="Retry" style="display: none;">${ICONS.RETRY}</button>
                </div>
            </div>`;
        }
        
        _cacheElements() {
            const sel = s => this.container.querySelector(s);
            this.elements = { 
                stateOverlay: sel('.immersion-state-overlay'), stateMessage: sel('.immersion-state-message'), 
                errorDetails: sel('.error-details'), exampleContent: sel('.immersion-example-content'), 
                image: sel('.example-image'), skeleton: sel('.skeleton-box'), 
                sentence: sel('.example-sentence'), translation: sel('.example-translation'), 
                regularNav: sel('.regular-nav'), counter: sel('.example-counter'), 
                playAllBtn: sel('[data-action="play-all"]'), loopBtn: sel('[data-action="toggle-loop"]'),
                retryBtn: sel('[data-action="retry"]'), audioBtn: sel('.ik-btn-overlay'),
                visualizerContainer: sel('.audio-visualizer-container'),
                visualizerCanvas: sel('#audio-visualizer')
            };
            this.visualizerCtx = this.elements.visualizerCanvas.getContext('2d');
            
            // Restore the loop button visual state after elements are cached
            if (this.elements.loopBtn) {
                this.elements.loopBtn.classList.toggle('is-active', this.isLoopingAudio);
            }
            // Ensure play-all button starts inactive
            if (this.elements.playAllBtn) {
                this.elements.playAllBtn.classList.remove('is-active');
                this.elements.playAllBtn.innerHTML = ICONS.PLAY;
            }
        }

        _addEventListeners() {
            this.container.addEventListener('click', (e) => {
                const actionTarget = e.target.closest('[data-action]');
                if (!actionTarget) return;
                const action = actionTarget.dataset.action;
                const actionMap = {
                    'play-audio': () => this.playCurrentAudio(),
                    'prev-example': () => this.navigate(-1),
                    'next-example': () => this.navigate(1),
                    'toggle-loop': () => this.toggleLoop(),
                    'play-all': () => this.handlePlayAll(),
                    'retry': () => this.retryCurrentFetch()
                };
                actionMap[action]?.();
            });
        }
        
        _setUIState(state, message = '', details = '') {
            this.elements.stateOverlay.style.display = 'flex';
            this.elements.exampleContent.style.display = 'none';
            this.elements.regularNav.style.display = 'none';
            this.elements.errorDetails.style.display = 'none';
            this.elements.retryBtn.style.display = 'none';

            switch(state) {
                case 'loading':
                    this.elements.stateMessage.textContent = message || 'Loading...';
                    break;
                case 'error':
                    this.elements.stateMessage.textContent = message || 'An error occurred.';
                    if (details) {
                        this.elements.errorDetails.innerHTML = `<div class="error-message"><strong>Details:</strong><br>${details}</div>`;
                        this.elements.errorDetails.style.display = 'block';
                    }
                    this.elements.retryBtn.style.display = 'inline-flex';
                    break;
                case 'empty':
                    this.elements.stateMessage.textContent = message || 'No examples found.';
                    break;
                case 'content':
                    this.elements.stateOverlay.style.display = 'none';
                    this.elements.exampleContent.style.display = 'flex';
                    this.elements.regularNav.style.display = 'flex';
                    break;
            }
        }

        async retryCurrentFetch() {
            if (this.lastSearchWord) {
                await this.fetchExamples(this.lastSearchWord);
            }
        }

        _updateContent() {
            if (this.examples.length === 0) return;
            const example = this.examples[this.currentIndex];

            this.elements.audioBtn.style.display = example.full_sound_url ? 'grid' : 'none';
            this.elements.skeleton.style.display = 'block';
            this.elements.image.style.display = 'none';
            
            this._loadImage(example.full_image_url);
            this.elements.sentence.textContent = example.sentence || '';
            this.elements.translation.textContent = example.translation || '';
            this._updateCounter();
        }

        _updateCounter() { this.elements.counter.textContent = `${this.currentIndex + 1} of ${this.examples.length}`; }

        navigate(direction) {
            if (this.examples.length < 2) return;
            this.stopCurrentAudio();
            // Don't reset loop state when navigating
            this.currentIndex = (this.currentIndex + direction + this.examples.length) % this.examples.length;
            this._updateContent();
            setTimeout(() => {
                this.playAudio(this.examples[this.currentIndex]?.full_sound_url);
                // If loop is enabled, start looping on the new example
                if (this.isLoopingAudio) {
                    this.audioLoop();
                }
            }, 100);
        }

        async _ensureMetadata() {
            if (this.deckTitleMap) return;
            try {
                const response = await serverFetch('https://apiv2.immersionkit.com/index_meta');
                this.deckTitleMap = (await response.json()).data || {};
            } catch (error) { this.deckTitleMap = {}; }
        }

        async fetchExamples(word) {
            this.lastSearchWord = word;
            this.stopCurrentAudio();
            // Reset play-all state when changing words (but preserve loop state)
            if (this.isPlayingAll) {
                this.handlePlayAll(false);
            }
            // Don't reset loop state when fetching new examples

            try {
                this._setUIState('loading', 'Finding contextual examples...');
                await this._ensureMetadata();
                const response = await serverFetch('https://apiv2.immersionkit.com/search', { q: word, exactMatch: 'false', limit: '50', sort: 'sentence_length:asc' });
                const rawExamples = (await response.json()).examples || [];
                
                if (rawExamples.length > 0) {
                    const linodeBaseUrl = 'https://us-southeast-1.linodeobjects.com/immersionkit/media/';
                    this.examples = rawExamples.map(ex => {
                        const slug = ex.title || '';
                        const prettyTitle = this.deckTitleMap?.[slug]?.title || slug;
                        const mediaType = ex.id?.split('_')[0] || '';
                        return { 
                            ...ex, 
                            full_image_url: ex.image ? `${linodeBaseUrl}${mediaType}/${prettyTitle}/media/${ex.image}` : '',
                            full_sound_url: ex.sound ? `${linodeBaseUrl}${mediaType}/${prettyTitle}/media/${ex.sound}` : ''
                        };
                    });
                    
                    // Preload images in background for faster navigation
                    const imageUrls = this.examples
                        .filter(ex => ex.full_image_url)
                        .map(ex => ex.full_image_url)
                        .slice(0, 5); // Preload first 5 images
                    
                    if (imageUrls.length > 0) {
                        imageOptimizer.preloadImagesInBackground(imageUrls);
                        performance.mark(`Started preloading ${imageUrls.length} images`);
                    }
                    
                    this.currentIndex = 0;
                    this._setUIState('content');
                    this._updateContent();
                    // Start audio playback, and if loop is enabled, it will automatically loop
                    setTimeout(() => {
                        this.playAudio(this.examples[0]?.full_sound_url);
                        // If loop state is persistent and enabled, start looping
                        if (this.isLoopingAudio) {
                            this.audioLoop();
                        }
                    }, 150);
                } else {
                    this._setUIState('empty', 'No examples found for this word.');
                }
            } catch (error) {
                this._setUIState('error', "Failed to fetch examples.", error.message);
            }
        }

        // ðŸš€ OPTIMIZATION: Background fetch method (non-blocking)
        async fetchExamplesBackground(word) {
            try {
                this.lastSearchWord = word;
                await this._ensureMetadata();
                const response = await serverFetch('https://apiv2.immersionkit.com/search', { q: word, exactMatch: 'false', limit: '50', sort: 'sentence_length:asc' });
                const rawExamples = (await response.json()).examples || [];
                
                if (rawExamples.length > 0) {
                    const linodeBaseUrl = 'https://us-southeast-1.linodeobjects.com/immersionkit/media/';
                    this.examples = rawExamples.map(ex => {
                        const slug = ex.title || '';
                        const prettyTitle = this.deckTitleMap?.[slug]?.title || slug;
                        const mediaType = ex.id?.split('_')[0] || '';
                        return { 
                            ...ex, 
                            full_image_url: ex.image ? `${linodeBaseUrl}${mediaType}/${prettyTitle}/media/${ex.image}` : '',
                            full_sound_url: ex.sound ? `${linodeBaseUrl}${mediaType}/${prettyTitle}/media/${ex.sound}` : ''
                        };
                    });
                    
                    // Preload images in background
                    const imageUrls = this.examples
                        .filter(ex => ex.full_image_url)
                        .map(ex => ex.full_image_url)
                        .slice(0, 5);
                    
                    if (imageUrls.length > 0) {
                        imageOptimizer.preloadImagesInBackground(imageUrls);
                    }
                    
                    this.currentIndex = 0;
                    this._setUIState('content');
                    this._updateContent();
                    
                    // Start audio if appropriate
                    setTimeout(() => {
                        if (this.examples[0]?.full_sound_url) {
                            this.playAudio(this.examples[0].full_sound_url);
                            if (this.isLoopingAudio) {
                                this.audioLoop();
                            }
                        }
                    }, 150);
                    
                    return true;
                } else {
                    this._setUIState('empty', 'No examples found for this word.');
                    return false;
                }
            } catch (error) {
                console.warn('Background examples loading failed:', error);
                this._setUIState('error', "Failed to fetch examples.", error.message);
                return false;
            }
        }

        _loadImage(url) {
            if (this.currentImageBlobUrl) URL.revokeObjectURL(this.currentImageBlobUrl);

            if (!url) {
                this.elements.skeleton.style.display = 'none';
                this.elements.image.style.display = 'none';
                return;
            }

            // Check if image is already preloaded and optimized
            const preloadedBlob = imageOptimizer.preloadedImages.get(url);
            if (preloadedBlob) {
                this.currentImageBlobUrl = URL.createObjectURL(preloadedBlob);
                this.elements.image.src = this.currentImageBlobUrl;
                this.elements.skeleton.style.display = 'none';
                this.elements.image.style.display = 'block';
                this.elements.image.classList.remove('loading');
                performance.mark('Image loaded from preload cache');
                return;
            }

            // Check image cache first
            if (imageCache.has(url)) {
                const cachedBlob = imageCache.get(url);
                this.currentImageBlobUrl = URL.createObjectURL(cachedBlob);
                this.elements.image.src = this.currentImageBlobUrl;
                this.elements.skeleton.style.display = 'none';
                this.elements.image.style.display = 'block';
                this.elements.image.classList.remove('loading');
                return;
            }

            this.elements.image.classList.add('loading');
            
            // Use image optimizer for loading and compression
            imageOptimizer.preloadImage(url).then(compressedBlob => {
                if (compressedBlob) {
                    // Also store in regular cache
                    if (imageCache.size < 50) {
                        imageCache.set(url, compressedBlob);
                    }
                    
                    this.currentImageBlobUrl = URL.createObjectURL(compressedBlob);
                    this.elements.image.src = this.currentImageBlobUrl;
                    this.elements.image.onload = () => {
                        this.elements.skeleton.style.display = 'none';
                        this.elements.image.style.display = 'block';
                        this.elements.image.classList.remove('loading');
                    };
                } else {
                    this.elements.skeleton.style.display = 'none';
                    this.elements.image.style.display = 'none';
                }
            }).catch(error => {
                console.warn("Image load failed:", error);
                this.elements.skeleton.style.display = 'none';
                this.elements.image.style.display = 'none';
            });
        }
        
        playCurrentAudio() { 
            // Don't reset loop state when playing current audio manually
            if (this.examples.length > 0) {
                this.playAudio(this.examples[this.currentIndex].full_sound_url);
                // If loop is enabled, start looping after manual play
                if (this.isLoopingAudio) {
                    this.audioLoop();
                }
            }
        }
        
        stopCurrentAudio() {
            if (this.currentAudioSource) {
                try {
                    this.currentAudioSource.onended = null;
                    this.currentAudioSource.stop(0);
                } catch (e) {}
                this.currentAudioSource = null;
            }
            if (this.visualizerAnimationId) {
                cancelAnimationFrame(this.visualizerAnimationId);
                this.visualizerAnimationId = null;
            }
            this.elements.visualizerContainer.classList.remove('is-playing');
            this.elements.audioBtn.innerHTML = ICONS.PLAY;
            
            // Clean up word character animations
            const wordChars = document.querySelectorAll('.word-char');
            wordChars.forEach(char => {
                char.classList.remove('frequency-high', 'frequency-mid', 'frequency-low', 'audio-active');
            });
            
            // Clean up particles
            const particleContainer = document.querySelector('.spectrogram-particles');
            if (particleContainer) {
                const particles = particleContainer.querySelectorAll('.spectrum-particle');
                particles.forEach(particle => {
                    particle.style.animation = 'none';
                    particle.style.opacity = '0';
                    setTimeout(() => {
                        if (particle.parentNode) {
                            particle.parentNode.removeChild(particle);
                        }
                    }, 100);
                });
            }
        }

        async playAudio(url) {
            return new Promise((resolve) => {
                if (!url) return resolve();
                const playId = ++this.lastPlayId;
                this.stopCurrentAudio();
                if (this.audioContext.state === 'suspended') this.audioContext.resume();
                this.elements.audioBtn.innerHTML = ICONS.STOP;
                
                serverFetch(url).then(res => res.arrayBuffer()).then(buffer => {
                    if (playId !== this.lastPlayId) return resolve();
                    this.audioContext.decodeAudioData(buffer, (decodedBuffer) => {
                        if (playId !== this.lastPlayId) return resolve();
                        
                        const source = this.audioContext.createBufferSource();
                        source.buffer = decodedBuffer;
                        source.connect(this.analyserNode);
                        this.analyserNode.connect(this.audioContext.destination);
                        source.start(0);
                        this.currentAudioSource = source;
                        this._visualize();
                        
                        source.onended = () => {
                            if (this.currentAudioSource === source) this.stopCurrentAudio();
                            resolve();
                        };
                    }, () => resolve());
                }).catch(() => resolve());
            });
        }

        _visualize() {
            this.elements.visualizerContainer.classList.add('is-playing');
            const bufferLength = this.analyserNode.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            const canvas = this.elements.visualizerCanvas;
            const ctx = this.visualizerCtx;
            
            // Get the current word for character animation
            const wordElement = document.querySelector('.word-main');
            let wordChars = [];
            
            // Convert word to individual character elements if not already done
            if (wordElement && !wordElement.querySelector('.word-char')) {
                const originalText = wordElement.textContent;
                wordElement.innerHTML = originalText
                    .split('')
                    .map(char => `<span class="word-char">${char}</span>`)
                    .join('');
            }
            
            // Get word character elements
            if (wordElement) {
                wordChars = Array.from(wordElement.querySelectorAll('.word-char'));
            }
            
            // Create particle container if it doesn't exist
            const wordContainer = document.getElementById('display-word');
            let particleContainer = wordContainer?.querySelector('.spectrogram-particles');
            if (wordContainer && !particleContainer) {
                particleContainer = document.createElement('div');
                particleContainer.className = 'spectrogram-particles';
                wordContainer.appendChild(particleContainer);
            }
            
            let frameCount = 0;
            const draw = () => {
                this.visualizerAnimationId = requestAnimationFrame(draw);
                this.analyserNode.getByteFrequencyData(dataArray);
                
                // Clear and draw spectrogram
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                const barWidth = (canvas.width / bufferLength) * 2.5;
                let x = 0;
                
                // Calculate frequency ranges for better analysis
                const lowFreqEnd = Math.floor(bufferLength * 0.1);
                const midFreqEnd = Math.floor(bufferLength * 0.4);
                
                let lowFreqAvg = 0, midFreqAvg = 0, highFreqAvg = 0;
                let lowCount = 0, midCount = 0, highCount = 0;
                
                // Draw spectrogram and calculate averages
                for (let i = 0; i < bufferLength; i++) {
                    const barHeight = (dataArray[i] / 255) * canvas.height * 0.8;
                    
                    // Create color gradient based on frequency
                    let color;
                    if (i < lowFreqEnd) {
                        color = `rgba(69, 183, 209, ${dataArray[i] / 255 * 0.9})`;
                        lowFreqAvg += dataArray[i];
                        lowCount++;
                    } else if (i < midFreqEnd) {
                        color = `rgba(78, 205, 196, ${dataArray[i] / 255 * 0.9})`;
                        midFreqAvg += dataArray[i];
                        midCount++;
                    } else {
                        color = `rgba(255, 107, 107, ${dataArray[i] / 255 * 0.9})`;
                        highFreqAvg += dataArray[i];
                        highCount++;
                    }
                    
                    ctx.fillStyle = color;
                    ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                    x += barWidth + 1;
                }
                
                // Calculate average frequencies
                lowFreqAvg = lowCount > 0 ? lowFreqAvg / lowCount : 0;
                midFreqAvg = midCount > 0 ? midFreqAvg / midCount : 0;
                highFreqAvg = highCount > 0 ? highFreqAvg / highCount : 0;
                
                // Animate word characters based on frequency analysis
                if (wordChars.length > 0) {
                    wordChars.forEach((char, index) => {
                        // Clear previous classes
                        char.classList.remove('frequency-high', 'frequency-mid', 'frequency-low', 'audio-active');
                        
                        // Determine which frequency range affects this character
                        const charPosition = index / wordChars.length;
                        let dominantFreq;
                        
                        if (charPosition < 0.33) {
                            dominantFreq = lowFreqAvg;
                        } else if (charPosition < 0.66) {
                            dominantFreq = midFreqAvg;
                        } else {
                            dominantFreq = highFreqAvg;
                        }
                        
                        // Apply animation classes based on frequency strength
                        if (dominantFreq > 120) {
                            char.classList.add('frequency-high');
                        } else if (dominantFreq > 80) {
                            char.classList.add('frequency-mid');
                        } else if (dominantFreq > 40) {
                            char.classList.add('frequency-low');
                        }
                        
                        // Add general audio active class for any significant activity
                        if (dominantFreq > 30) {
                            char.classList.add('audio-active');
                        }
                    });
                }
                
                // Create particle effects every few frames
                frameCount++;
                if (frameCount % 8 === 0 && particleContainer) {
                    this._createSpectrumParticles(particleContainer, lowFreqAvg, midFreqAvg, highFreqAvg);
                }
            };
            draw();
        }
        
        _createSpectrumParticles(container, lowFreq, midFreq, highFreq) {
            const frequencies = [
                { value: lowFreq, class: 'low-freq', threshold: 40 },
                { value: midFreq, class: 'mid-freq', threshold: 60 },
                { value: highFreq, class: 'high-freq', threshold: 80 }
            ];
            
            frequencies.forEach(freq => {
                if (freq.value > freq.threshold) {
                    const particle = document.createElement('div');
                    particle.className = `spectrum-particle ${freq.class}`;
                    
                    // Random positioning
                    const size = Math.random() * 8 + 4;
                    particle.style.width = `${size}px`;
                    particle.style.height = `${size}px`;
                    particle.style.left = `${Math.random() * 100}%`;
                    particle.style.bottom = '0px';
                    
                    container.appendChild(particle);
                    
                    // Remove particle after animation
                    setTimeout(() => {
                        if (particle.parentNode) {
                            particle.parentNode.removeChild(particle);
                        }
                    }, 2500);
                }
            });
            
            // Cleanup old particles to prevent memory leaks
            const particles = container.querySelectorAll('.spectrum-particle');
            if (particles.length > 50) {
                for (let i = 0; i < 10; i++) {
                    if (particles[i] && particles[i].parentNode) {
                        particles[i].parentNode.removeChild(particles[i]);
                    }
                }
            }
        }

        toggleLoop(forceState) {
            this.isLoopingAudio = forceState !== undefined ? forceState : !this.isLoopingAudio;
            // Save loop state to localStorage with versioned key for persistence
            localStorage.setItem(`jdojo_${CACHE_VERSION}_loop_state`, this.isLoopingAudio.toString());
            if (this.isLoopingAudio) {
                if (this.isPlayingAll) this.handlePlayAll(false);
                this.audioLoop();
            } else { this.stopCurrentAudio(); }
            this.elements.loopBtn.classList.toggle('is-active', this.isLoopingAudio);
        }
        
        async audioLoop() {
            if (!this.isLoopingAudio || !this.examples[this.currentIndex]) return;
            const example = this.examples[this.currentIndex];
            if (example?.full_sound_url) {
                await this.playAudio(example.full_sound_url);
                if (this.isLoopingAudio) setTimeout(() => this.audioLoop(), 200);
            } else { this.toggleLoop(false); }
        }
        
        handlePlayAll(forceState) {
            this.isPlayingAll = forceState !== undefined ? forceState : !this.isPlayingAll;
            if (this.isPlayingAll) {
                // When starting play-all, turn off loop functionality and update button state
                if (this.isLoopingAudio) {
                    this.toggleLoop(false); // This will turn off loop and update UI
                }
                this.playAllSequence();
            } else {
                this.stopCurrentAudio();
            }
            this.elements.playAllBtn.innerHTML = this.isPlayingAll ? ICONS.STOP : ICONS.PLAY;
            this.elements.playAllBtn.classList.toggle('is-active', this.isPlayingAll);
        }
        
        async playAllSequence() {
            if (this.examples.length === 0) { this.handlePlayAll(false); return; }
            let initialIndex = this.currentIndex;
            for (let i = 0; i < this.examples.length && this.isPlayingAll; i++) {
                this.currentIndex = (initialIndex + i) % this.examples.length;
                this._updateContent();
                const example = this.examples[this.currentIndex];
                if (example?.full_sound_url) {
                    await this.playAudio(example.full_sound_url);
                    if (this.isPlayingAll) await new Promise(res => setTimeout(res, 400));
                }
            }
            this.handlePlayAll(false);
            // Loop state was explicitly turned off when play-all started, so don't resume it
        }
    }
    const immersionHandler = new ImmersionKitHandler();

    // --- RTK Edit Functionality ---
    let currentEditingKanji = null;
    
    function openRTKEditModal(kanji, meaning, rtk) {
        currentEditingKanji = kanji;
        
        const modal = document.getElementById('rtk-edit-modal');
        const kanjiSpan = document.getElementById('rtk-edit-kanji');
        const textarea = document.getElementById('rtk-edit-textarea');
        
        kanjiSpan.textContent = `${kanji} (${meaning})`;
        textarea.value = rtk || '';
        
        modal.classList.add('active');
        
        // Focus on textarea after animation
        setTimeout(() => {
            textarea.focus();
            textarea.setSelectionRange(textarea.value.length, textarea.value.length);
        }, 300);
        
        // Add escape key listener
        document.addEventListener('keydown', handleEscapeKey);
    }
    
    function closeRTKEditModal() {
        const modal = document.getElementById('rtk-edit-modal');
        modal.classList.remove('active');
        currentEditingKanji = null;
        
        // Remove escape key listener
        document.removeEventListener('keydown', handleEscapeKey);
        
        // Reset form state
        const saveBtn = document.getElementById('rtk-save-btn');
        const saveText = saveBtn.querySelector('.rtk-save-text');
        const loading = saveBtn.querySelector('.rtk-edit-loading');
        
        saveBtn.disabled = false;
        saveText.style.display = 'inline';
        loading.style.display = 'none';
    }
    
    function handleEscapeKey(event) {
        if (event.key === 'Escape') {
            closeRTKEditModal();
        }
    }
    
    async function saveRTKEdit(event) {
        event.preventDefault();
        
        if (!currentEditingKanji) {
            console.error('No kanji selected for editing');
            return;
        }
        
        const textarea = document.getElementById('rtk-edit-textarea');
        const saveBtn = document.getElementById('rtk-save-btn');
        const saveText = saveBtn.querySelector('.rtk-save-text');
        const loading = saveBtn.querySelector('.rtk-edit-loading');
        const newRTK = textarea.value.trim();
        
        // Show loading state
        saveBtn.disabled = true;
        saveText.style.display = 'none';
        loading.style.display = 'inline-flex';
        
        try {
            const response = await fetch(`/api/kanji/${encodeURIComponent(currentEditingKanji)}/rtk`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ rtk: newRTK })
            });
            
            const result = await response.json();
            
            if (response.ok) {
                // Update the local kanji data
                const kanjiData = kanjiMap.get(currentEditingKanji);
                if (kanjiData) {
                    kanjiData.rtk = newRTK;
                }
                
                // Update the KANJI_DATA array as well
                const kanjiIndex = KANJI_DATA.findIndex(k => k.kanji === currentEditingKanji);
                if (kanjiIndex !== -1) {
                    KANJI_DATA[kanjiIndex].rtk = newRTK;
                }
                
                // Refresh the kanji breakdown display
                refreshKanjiDisplay();
                
                // Show success message
                showNotification('RTK updated successfully!', 'success');
                
                closeRTKEditModal();
            } else {
                throw new Error(result.error || 'Failed to update RTK');
            }
        } catch (error) {
            console.error('Error updating RTK:', error);
            showNotification(`Error: ${error.message}`, 'error');
            
            // Reset button state
            saveBtn.disabled = false;
            saveText.style.display = 'inline';
            loading.style.display = 'none';
        }
    }
    
    function refreshKanjiDisplay() {
        const currentWord = document.querySelector('.word-main').textContent;
        if (!currentWord) return;
        
        const kanjiBreakdownEl = document.getElementById('kanji-breakdown');
        const uniqueKanji = [...new Set(currentWord.match(/[\u4e00-\u9faf]/g) || [])];
        
        if (uniqueKanji.length > 0) {
            const kanjiDataList = uniqueKanji.map(kanji => kanjiMap.get(kanji)).filter(Boolean);
            
            if (kanjiDataList.length > 0) {
                const virtualRenderer = new VirtualScrollRenderer(kanjiBreakdownEl);
                virtualRenderer.setItems(kanjiDataList);
            }
        }
    }
    
    function showNotification(message, type = 'info') {
        // Create notification element
        const notification = document.createElement('div');
        notification.className = `notification notification-${type}`;
        notification.innerHTML = `
            <div class="notification-content">
                <span class="notification-icon">${type === 'success' ? 'âœ…' : type === 'error' ? 'âŒ' : 'â„¹ï¸'}</span>
                <span class="notification-message">${message}</span>
            </div>
        `;
        
        // Add styles if not already added
        if (!document.getElementById('notification-styles')) {
            const style = document.createElement('style');
            style.id = 'notification-styles';
            style.textContent = `
                .notification {
                    position: fixed;
                    top: 2rem;
                    right: 2rem;
                    padding: 1rem 1.5rem;
                    border-radius: var(--border-radius-md);
                    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
                    z-index: 10001;
                    animation: slideInRight 0.3s ease, fadeOut 0.3s ease 2.7s forwards;
                    backdrop-filter: blur(10px);
                    border: 1px solid rgba(255, 255, 255, 0.2);
                }
                
                .notification-success {
                    background: rgba(52, 168, 83, 0.95);
                    color: white;
                }
                
                .notification-error {
                    background: rgba(234, 67, 53, 0.95);
                    color: white;
                }
                
                .notification-info {
                    background: rgba(26, 115, 232, 0.95);
                    color: white;
                }
                
                .notification-content {
                    display: flex;
                    align-items: center;
                    gap: 0.75rem;
                }
                
                .notification-icon {
                    font-size: 1.25rem;
                }
                
                .notification-message {
                    font-weight: 500;
                }
                
                @keyframes slideInRight {
                    from {
                        transform: translateX(100%);
                        opacity: 0;
                    }
                    to {
                        transform: translateX(0);
                        opacity: 1;
                    }
                }
                
                @keyframes fadeOut {
                    to {
                        opacity: 0;
                        transform: translateX(100%);
                    }
                }
            `;
            document.head.appendChild(style);
        }
        
        // Add to page
        document.body.appendChild(notification);
        
        // Remove after animation
        setTimeout(() => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
        }, 3000);
    }

    // --- Event Listeners & Initialization ---
    randomWordBtn.addEventListener('click', showRandomWord);

    copyWordBtn.addEventListener('click', () => {
        const word = document.querySelector('.word-main').textContent;
        if (!word) return;
        navigator.clipboard.writeText(word).then(() => {
            const originalTitle = copyWordBtn.title;
            copyWordBtn.title = 'Copied!';
            setTimeout(() => { copyWordBtn.title = originalTitle; }, 2000);
        });
    });

    document.addEventListener('DOMContentLoaded', function() {
        performance.mark('DOM loaded');
        CacheManager.clearOldCache();
        
        // Register service worker for offline caching
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/sw.js')
                .then(registration => {
                    console.log('ðŸ”§ Service Worker registered:', registration);
                    performance.mark('Service Worker registered');
                })
                .catch(error => {
                    console.warn('Service Worker registration failed:', error);
                });
        }
        
        // Try to load from cache first
        const cachedWords = CacheManager.getCache('words');
        const cachedKanji = CacheManager.getCache('kanji');
        
        if (cachedWords && cachedKanji) {
            performance.mark('Loading from cache');
            performance.recordCacheHit();
            performance.recordCacheHit(); // Two cache hits for words and kanji
            WORD_LIST = cachedWords;
            KANJI_DATA = cachedKanji;
            performance.metrics.totalWords = WORD_LIST.length;
            performance.metrics.totalKanji = KANJI_DATA.length;
            kanjiMap = new Map(KANJI_DATA.map(item => [item.kanji, item]));
            performance.mark('Cache data processed');
            showRandomWord();
            performance.mark('First word displayed');
        } else {
            // Load from API with loading indicator
            performance.mark('Loading from API');
            performance.recordCacheMiss();
            performance.recordCacheMiss(); // Two cache misses for words and kanji
            performance.recordApiCall();
            performance.recordApiCall(); // Two API calls for words and kanji
            Promise.all([
                fetch("/api/words").then(res => res.ok ? res.json() : Promise.reject(res)),
                fetch("/api/kanji").then(res => res.ok ? res.json() : Promise.reject(res))
            ])
            .then(([wordData, kanjiData]) => {
                performance.mark('API data received');
                WORD_LIST = wordData;
                KANJI_DATA = kanjiData;
                kanjiMap = new Map(KANJI_DATA.map(item => [item.kanji, item]));
                
                // Cache the data
                CacheManager.setCache('words', wordData);
                CacheManager.setCache('kanji', kanjiData);
                
                performance.mark('Data cached and processed');
                showRandomWord();
                performance.mark('First word displayed');
            })
            .catch(error => {
                console.error("âŒ Error loading initial data:", error);
                const contentGrid = document.getElementById('content-grid');
                contentGrid.innerHTML = `<div class="error-message" style="grid-column: 1 / -1;"><strong>Failed to start the app.</strong><br>Could not load essential data. Please refresh the page.</div>`;
                randomWordBtn.disabled = true;
                randomWordBtn.querySelector('.btn-icon').style.display = 'none';
            });
        }
    });
    </script>
</body>
</html>